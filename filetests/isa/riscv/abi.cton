; Test the legalization of function signatures.
test legalizer
isa riscv

; regex: V=v\d+
; regex: VX=vx\d+

function f(i32) {
    sig0 = signature(i32) -> i32
    ; check: sig0 = signature(i32 [%x10]) -> i32 [%x10]

    sig1 = signature(i64) -> b1
    ; check: sig1 = signature(i32 [%x10], i32 [%x11]) -> b1 [%x10]

    ; The i64 argument must go in an even-odd register pair.
    sig2 = signature(f32, i64) -> f64
    ; check: sig2 = signature(f32 [%f10], i32 [%x12], i32 [%x13]) -> f64 [%f10]

    ; Spilling into the stack args.
    sig3 = signature(f64, f64, f64, f64, f64, f64, f64, i64) -> f64
    ; check: sig3 = signature(f64 [%f10], f64 [%f11], f64 [%f12], f64 [%f13], f64 [%f14], f64 [%f15], f64 [%f16], i32 [0], i32 [4]) -> f64 [%f10]

    ; Splitting vectors.
    sig4 = signature(i32x4)
    ; check: sig4 = signature(i32 [%x10], i32 [%x11], i32 [%x12], i32 [%x13])

    ; Splitting vectors, then splitting ints.
    sig5 = signature(i64x4)
    ; check: sig5 = signature(i32 [%x10], i32 [%x11], i32 [%x12], i32 [%x13], i32 [%x14], i32 [%x15], i32 [%x16], i32 [%x17])

ebb0(v0: i32):
    return_reg v0
}

function int_split_args(i64) -> i64 {
ebb0(v0: i64):
    ; check: $ebb0($(v0l=$VX): i32, $(v0h=$VX): i32):
    ; check: iconcat_lohi $v0l, $v0h
    v1 = iadd_imm v0, 1
    ; check: $(v1l=$V), $(v1h=$VX) = isplit_lohi $v1
    ; check: return $v1l, $v1h
    return v1
}

function int_ext(i8, i8 sext, i8 uext) -> i8 uext {
ebb0(v1: i8, v2: i8, v3: i8):
    ; check: $ebb0($v1: i8, $(v2x=$VX): i32, $(v3x=$VX): i32):
    ; check: ireduce.i8 $v2x
    ; check: ireduce.i8 $v3x
    ; check: $(v1x=$V) = uextend.i32 $v1
    ; check: return $v1x
    return v1
}

function vector_split_args(i64x4) -> i64x4 {
ebb0(v0: i64x4):
    ; check: $ebb0($(v0al=$VX): i32, $(v0ah=$VX): i32, $(v0bl=$VX): i32, $(v0bh=$VX): i32, $(v0cl=$VX): i32, $(v0ch=$VX): i32, $(v0dl=$VX): i32, $(v0dh=$VX): i32):
    ; check: $(v0a=$V) = iconcat_lohi $v0al, $v0ah
    ; check: $(v0b=$V) = iconcat_lohi $v0bl, $v0bh
    ; check: $(v0ab=$V) = vconcat $v0a, $v0b
    ; check: $(v0c=$V) = iconcat_lohi $v0cl, $v0ch
    ; check: $(v0d=$V) = iconcat_lohi $v0dl, $v0dh
    ; check: $(v0cd=$V) = vconcat $v0c, $v0d
    ; check: $(v0abcd=$V) = vconcat $v0ab, $v0cd
    v1 = iadd v0, v0
    ; check: $(v1ab=$V), $(v1cd=$VX) = vsplit
    ; check: $(v1a=$V), $(v1b=$VX) = vsplit $v1ab
    ; check: $(v1al=$V), $(v1ah=$VX) = isplit_lohi $v1a
    ; check: $(v1bl=$V), $(v1bh=$VX) = isplit_lohi $v1b
    ; check: $(v1c=$V), $(v1d=$VX) = vsplit $v1cd
    ; check: $(v1cl=$V), $(v1ch=$VX) = isplit_lohi $v1c
    ; check: $(v1dl=$V), $(v1dh=$VX) = isplit_lohi $v1d
    ; check: return $v1al, $v1ah, $v1bl, $v1bh, $v1cl, $v1ch, $v1dl, $v1dh
    return v1
}

function parse_encoding(i32 [%x5]) -> i32 [%x10] {
    ; check: function parse_encoding(i32 [%x5]) -> i32 [%x10] {

    sig0 = signature(i32 [%x10]) -> i32 [%x10]
    ; check: sig0 = signature(i32 [%x10]) -> i32 [%x10]

    sig1 = signature(i32 [%x10], i32 [%x11]) -> b1 [%x10]
    ; check: sig1 = signature(i32 [%x10], i32 [%x11]) -> b1 [%x10]

    sig2 = signature(f32 [%f10], i32 [%x12], i32 [%x13]) -> f64 [%f10]
    ; check: sig2 = signature(f32 [%f10], i32 [%x12], i32 [%x13]) -> f64 [%f10]

    ; Arguments on stack where not necessary
    sig3 = signature(f64 [%f10], i32 [0], i32 [4]) -> f64 [%f10]
    ; check: sig3 = signature(f64 [%f10], i32 [0], i32 [4]) -> f64 [%f10]

    ; Stack argument before register argument
    sig4 = signature(f32 [72], i32 [%x10])
    ; check: sig4 = signature(f32 [72], i32 [%x10])

    ; Return value on stack
    sig5 = signature() -> f32 [0]
    ; check: sig5 = signature() -> f32 [0]

    ; function + signature
    fn15 = function bar(i32 [%x10]) -> b1 [%x10]
    ; check: sig6 = signature(i32 [%x10]) -> b1 [%x10]
    ; nextln: fn0 = sig6 bar

ebb0(v0: i32):
    return v0
}
