; Test the custom legalizations.
test legalizer
isa intel
set is_64bit
isa intel

; regex: V=v\d+
; regex: EBB=ebb\d+

function %cond_trap(i32) {
ebb0(v1: i32):
    trapz v1, user67
    return
    ; check: $ebb0($v1: i32):
    ; nextln: brnz $v1, $(new=$EBB)
    ; nextln: trap user67
    ; check: $new:
    ; nextln: return
}

function %cond_trap2(i32) {
ebb0(v1: i32):
    trapnz v1, int_ovf
    return
    ; check: $ebb0($v1: i32):
    ; nextln: brz $v1, $(new=$EBB)
    ; nextln: trap int_ovf
    ; check: $new:
    ; nextln: return
}

function %cond_trap_b1(i32) {
ebb0(v1: i32):
    v2 = icmp_imm eq v1, 6
    trapz v2, user7
    return
    ; check: $ebb0($v1: i32):
    ; check: brnz $v2, $(new=$EBB)
    ; nextln: trap user7
    ; check: $new:
    ; nextln: return
}

function %cond_trap2_b1(i32) {
ebb0(v1: i32):
    v2 = icmp_imm eq v1, 6
    trapnz v2, user9
    return
    ; check: $ebb0($v1: i32):
    ; check: brz $v2, $(new=$EBB)
    ; nextln: trap user9
    ; check: $new:
    ; nextln: return
}

function %f32const() -> f32 {
ebb0:
    v1 = f32const 0x1.0p1
    ; check: $(tmp=$V) = iconst.i32
    ; check: $v1 = bitcast.f32 $tmp
    return v1
}

function %f64const() -> f64 {
ebb0:
    v1 = f64const 0x1.0p1
    ; check: $(tmp=$V) = iconst.i64
    ; check: $v1 = bitcast.f64 $tmp
    return v1
}
