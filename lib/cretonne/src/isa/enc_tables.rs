//! Support types for generated encoding tables.
//!
//! This module contains types and functions for working with the encoding tables generated by
//! `lib/cretonne/meta/gen_encoding.py`.

use constant_hash::{Table, probe};
use ir::{Type, Opcode, InstructionData};
use isa::{Encoding, Legalize};
use settings::PredicateView;
use std::ops::Range;

/// A recipe predicate.
///
/// This is a predicate function capable of testing ISA and instruction predicates simultaneously.
///
/// A None predicate is always satisfied.
pub type RecipePredicate = Option<fn(PredicateView, &InstructionData) -> bool>;

/// Legalization action to perform when no encoding can be found for an instruction.
///
/// This is an index into an ISA-specific table of legalization actions.
pub type LegalizeCode = u8;

/// Level 1 hash table entry.
///
/// One level 1 hash table is generated per CPU mode. This table is keyed by the controlling type
/// variable, using `VOID` for non-polymorphic instructions.
///
/// The hash table values are references to level 2 hash tables, encoded as an offset in `LEVEL2`
/// where the table begins, and the binary logarithm of its length. All the level 2 hash tables
/// have a power-of-two size.
///
/// Entries are generic over the offset type. It will typically be `u32` or `u16`, depending on the
/// size of the `LEVEL2` table.
///
/// Empty entries are encoded with a `!0` value for `log2len` which will always be out of range.
/// Entries that have a `legalize` value but no level 2 table have an `offset` field that is out f
/// bounds.
pub struct Level1Entry<OffT: Into<u32> + Copy> {
    pub ty: Type,
    pub log2len: u8,
    pub legalize: LegalizeCode,
    pub offset: OffT,
}

impl<OffT: Into<u32> + Copy> Level1Entry<OffT> {
    /// Get the level 2 table range indicated by this entry.
    fn range(&self) -> Range<usize> {
        let b = self.offset.into() as usize;
        b..b + (1 << self.log2len)
    }
}

impl<OffT: Into<u32> + Copy> Table<Type> for [Level1Entry<OffT>] {
    fn len(&self) -> usize {
        self.len()
    }

    fn key(&self, idx: usize) -> Option<Type> {
        if self[idx].log2len != !0 {
            Some(self[idx].ty)
        } else {
            None
        }
    }
}

/// Level 2 hash table entry.
///
/// The second level hash tables are keyed by `Opcode`, and contain an offset into the `ENCLISTS`
/// table where the encoding recipes for the instruction are stored.
///
/// Entries are generic over the offset type which depends on the size of `ENCLISTS`. A `u16`
/// offset allows the entries to be only 32 bits each. There is no benefit to dropping down to `u8`
/// for tiny ISAs. The entries won't shrink below 32 bits since the opcode is expected to be 16
/// bits.
///
/// Empty entries are encoded with a `NotAnOpcode` `opcode` field.
pub struct Level2Entry<OffT: Into<u32> + Copy> {
    pub opcode: Option<Opcode>,
    pub offset: OffT,
}

impl<OffT: Into<u32> + Copy> Table<Opcode> for [Level2Entry<OffT>] {
    fn len(&self) -> usize {
        self.len()
    }

    fn key(&self, idx: usize) -> Option<Opcode> {
        self[idx].opcode
    }
}

/// Two-level hash table lookup.
///
/// Given the controlling type variable and instruction opcode, find the corresponding encoding
/// list.
///
/// Returns an offset into the ISA's `ENCLIST` table, or `None` if the opcode/type combination is
/// not legal.
pub fn lookup_enclist<OffT1, OffT2>(ctrl_typevar: Type,
                                    opcode: Opcode,
                                    level1_table: &[Level1Entry<OffT1>],
                                    level2_table: &[Level2Entry<OffT2>])
                                    -> Result<usize, Legalize>
    where OffT1: Into<u32> + Copy,
          OffT2: Into<u32> + Copy
{
    match probe(level1_table, ctrl_typevar, ctrl_typevar.index()) {
        Err(l1idx) => {
            // No level 1 entry found for the type.
            // We have a sentinel entry with the default legalization code.
            let l1ent = &level1_table[l1idx];
            Err(l1ent.legalize.into())
        }
        Ok(l1idx) => {
            // We have a valid level 1 entry for this type.
            let l1ent = &level1_table[l1idx];
            match level2_table.get(l1ent.range()) {
                Some(l2tab) => {
                    probe(l2tab, opcode, opcode as usize)
                        .map(|l2idx| l2tab[l2idx].offset.into() as usize)
                        .map_err(|_| l1ent.legalize.into())
                }
                None => {
                    // The l1ent range is invalid. This means that we just have a customized
                    // legalization code for this type. The level 2 table is empty.
                    Err(l1ent.legalize.into())
                }
            }
        }
    }
}

/// Encoding list entry.
///
/// Encoding lists are represented as sequences of u16 words.
pub type EncListEntry = u16;

/// Number of bits used to represent a predicate. c.f. `meta.gen_encoding.py`.
const PRED_BITS: u8 = 12;
const PRED_MASK: EncListEntry = (1 << PRED_BITS) - 1;

/// The match-always instruction predicate. c.f. `meta.gen_encoding.py`.
const CODE_ALWAYS: EncListEntry = PRED_MASK;

/// The encoding list terminator.
const CODE_FAIL: EncListEntry = 0xffff;

/// An iterator over legal encodings for the instruction.
pub struct Encodings<'a> {
    offset: usize,
    enclist: &'static [EncListEntry],
    inst: &'a InstructionData,
    instp: fn(&InstructionData, EncListEntry) -> bool,
    isa_predicates: PredicateView<'a>,
    recipe_predicates: &'static [RecipePredicate],
}

impl<'a> Encodings<'a> {
    /// Creates a new instance of `Encodings`.
    ///
    /// # Parameters
    ///
    /// - `offset` an offset into encoding list returned by `lookup_enclist` function.
    /// - `enclist` a list of encoding entries.
    /// - `recipe_predicates` is a slice of recipe predicate functions.
    /// - `inst` the current instruction.
    /// - `instp` an instruction predicate number to be evaluated on the current instruction.
    /// - `isa_predicate_bytes` an ISA flags as a slice of bytes to evaluate an ISA predicate number
    /// on the current instruction.
    ///
    /// This iterator provides search for encodings that applies to the given instruction. The
    /// encoding lists are laid out such that first call to `next` returns valid entry in the list
    /// or `None`.
    pub fn new(offset: usize,
               enclist: &'static [EncListEntry],
               recipe_predicates: &'static [RecipePredicate],
               inst: &'a InstructionData,
               instp: fn(&InstructionData, EncListEntry) -> bool,
               isa_predicates: PredicateView<'a>)
               -> Self {
        Encodings {
            offset,
            enclist,
            inst,
            instp,
            isa_predicates,
            recipe_predicates,
        }
    }

    /// Check if the predicate for `recipe` is satisfied.
    fn check_recipe(&self, recipe: u16) -> bool {
        match self.recipe_predicates[recipe as usize] {
            Some(p) => p(self.isa_predicates, self.inst),
            None => true,
        }
    }
}

impl<'a> Iterator for Encodings<'a> {
    type Item = Encoding;

    fn next(&mut self) -> Option<Encoding> {
        while self.enclist[self.offset] != CODE_FAIL {
            let pred = self.enclist[self.offset];
            if pred <= CODE_ALWAYS {
                // This is an instruction predicate followed by recipe and encbits entries.
                self.offset += 3;
                if pred == CODE_ALWAYS || (self.instp)(self.inst, pred) {
                    let recipe = self.enclist[self.offset - 2];
                    if self.check_recipe(recipe) {
                        let encoding = Encoding::new(recipe, self.enclist[self.offset - 1]);
                        return Some(encoding);
                    }
                }
            } else {
                // This is an ISA predicate entry.
                self.offset += 1;
                if !self.isa_predicates.test((pred & PRED_MASK) as usize) {
                    // ISA predicate failed, skip the next N entries.
                    self.offset += 3 * (pred >> PRED_BITS) as usize;
                }
            }
        }
        None
    }
}
