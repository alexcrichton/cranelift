//! Support types for generated encoding tables.
//!
//! This module contains types and functions for working with the encoding tables generated by
//! `lib/cretonne/meta/gen_encoding.py`.
use ir::{Type, Opcode, InstructionData};
use isa::{Encoding, Legalize};
use constant_hash::{Table, probe};
use std::ops::Range;

/// Level 1 hash table entry.
///
/// One level 1 hash table is generated per CPU mode. This table is keyed by the controlling type
/// variable, using `VOID` for non-polymorphic instructions.
///
/// The hash table values are references to level 2 hash tables, encoded as an offset in `LEVEL2`
/// where the table begins, and the binary logarithm of its length. All the level 2 hash tables
/// have a power-of-two size.
///
/// Entries are generic over the offset type. It will typically be `u32` or `u16`, depending on the
/// size of the `LEVEL2` table. A `u16` offset allows entries to shrink to 32 bits each, but some
/// ISAs may have tables so large that `u32` offsets are needed.
///
/// Empty entries are encoded with a 0 `log2len`. This is on the assumption that no level 2 tables
/// have only a single entry.
pub struct Level1Entry<OffT: Into<u32> + Copy> {
    pub ty: Type,
    pub log2len: u8,
    pub offset: OffT,
}

impl<OffT: Into<u32> + Copy> Level1Entry<OffT> {
    /// Get the level 2 table range indicated by this entry.
    fn range(&self) -> Range<usize> {
        let b = self.offset.into() as usize;
        b..b + (1 << self.log2len)
    }
}

impl<OffT: Into<u32> + Copy> Table<Type> for [Level1Entry<OffT>] {
    fn len(&self) -> usize {
        self.len()
    }

    fn key(&self, idx: usize) -> Option<Type> {
        if self[idx].log2len != 0 {
            Some(self[idx].ty)
        } else {
            None
        }
    }
}

/// Level 2 hash table entry.
///
/// The second level hash tables are keyed by `Opcode`, and contain an offset into the `ENCLISTS`
/// table where the encoding recipes for the instrution are stored.
///
/// Entries are generic over the offset type which depends on the size of `ENCLISTS`. A `u16`
/// offset allows the entries to be only 32 bits each. There is no benefit to dropping down to `u8`
/// for tiny ISAs. The entries won't shrink below 32 bits since the opcode is expected to be 16
/// bits.
///
/// Empty entries are encoded with a `NotAnOpcode` `opcode` field.
pub struct Level2Entry<OffT: Into<u32> + Copy> {
    pub opcode: Option<Opcode>,
    pub offset: OffT,
}

impl<OffT: Into<u32> + Copy> Table<Opcode> for [Level2Entry<OffT>] {
    fn len(&self) -> usize {
        self.len()
    }

    fn key(&self, idx: usize) -> Option<Opcode> {
        self[idx].opcode
    }
}

/// Two-level hash table lookup.
///
/// Given the controlling type variable and instruction opcode, find the corresponding encoding
/// list.
///
/// Returns an offset into the ISA's `ENCLIST` table, or `None` if the opcode/type combination is
/// not legal.
pub fn lookup_enclist<OffT1, OffT2>(ctrl_typevar: Type,
                                    opcode: Opcode,
                                    level1_table: &[Level1Entry<OffT1>],
                                    level2_table: &[Level2Entry<OffT2>])
                                    -> Result<usize, Legalize>
    where OffT1: Into<u32> + Copy,
          OffT2: Into<u32> + Copy
{
    // TODO: The choice of legalization actions here is naive. This needs to be configurable.
    match probe(level1_table, ctrl_typevar, ctrl_typevar.index()) {
        Err(_) => {
            // No level 1 entry for the type.
            Err(if ctrl_typevar.lane_type().bits() > 32 {
                    Legalize::Narrow
                } else {
                    Legalize::Expand
                })
        }
        Ok(l1idx) => {
            let l1ent = &level1_table[l1idx];
            let l2tab = &level2_table[l1ent.range()];
            probe(l2tab, opcode, opcode as usize)
                .map(|l2idx| l2tab[l2idx].offset.into() as usize)
                .map_err(|_| Legalize::Expand)
        }
    }
}

/// Encoding list entry.
///
/// Encoding lists are represented as sequences of u16 words.
pub type EncListEntry = u16;

/// Number of bits used to represent a predicate. c.f. `meta.gen_encoding.py`.
const PRED_BITS: u8 = 12;
const PRED_MASK: EncListEntry = (1 << PRED_BITS) - 1;

/// The match-always instruction predicate. c.f. `meta.gen_encoding.py`.
const CODE_ALWAYS: EncListEntry = PRED_MASK;

/// The encoding list terminator.
const CODE_FAIL: EncListEntry = 0xffff;

/// An iterator over legal encodings for the instruction.
pub struct Encodings<'a, 'b> {
    offset: usize,
    enclist: &'b [EncListEntry],
    inst: &'b InstructionData,
    instp: fn(&InstructionData, EncListEntry) -> bool,
    isa_predicate_bytes: &'a [u8],
}

impl<'a, 'b> Encodings<'a, 'b> {
    /// Creates a new instance of `Encodings`.
    ///
    /// # Parameters
    ///
    /// - `offset` an offset into encoding list returned by `lookup_enclist` function.
    /// - `inst` the current instruction.
    /// - `enclist` a list of encoding entries.
    /// - `instp` an instruction predicate number to be evaluated on the current instruction.
    /// - `isa_predicate_bytes` an ISA flags as a slice of bytes to evaluate an ISA predicate number
    /// on the current instruction.
    ///
    /// This iterator provides search for encodings that applies to the given instruction. The
    /// encoding lists are laid out such that first call to `next` returns valid entry in the list
    /// or `None`.
    pub fn new(offset: usize,
               enclist: &'b [EncListEntry],
               inst: &'b InstructionData,
               instp: fn(&InstructionData, EncListEntry) -> bool,
               isa_predicate_bytes: &'a [u8])
               -> Self {
        Encodings {
            offset,
            enclist,
            inst,
            instp,
            isa_predicate_bytes,
        }
    }
}

impl<'a, 'b> Iterator for Encodings<'a, 'b> {
    type Item = Encoding;

    fn next(&mut self) -> Option<Encoding> {
        fn numbered_predicate(bytes: &[u8], p: usize) -> bool {
            bytes[p / 8] & (1 << (p % 8)) != 0
        }

        while self.enclist[self.offset] != CODE_FAIL {
            let pred = self.enclist[self.offset];
            if pred <= CODE_ALWAYS {
                // This is an instruction predicate followed by recipe and encbits entries.
                if pred == CODE_ALWAYS || (self.instp)(self.inst, pred) {
                    let encoding = Encoding::new(self.enclist[self.offset + 1],
                                                 self.enclist[self.offset + 2]);
                    self.offset += 3;
                    return Some(encoding);
                } else {
                    self.offset += 3;
                }
            } else {
                // This is an ISA predicate entry.
                self.offset += 1;
                if !numbered_predicate(self.isa_predicate_bytes, (pred & PRED_MASK) as usize) {
                    // ISA predicate failed, skip the next N entries.
                    self.offset += 3 * (pred >> PRED_BITS) as usize;
                }
            }
        }
        None
    }
}
